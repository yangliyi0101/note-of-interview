https://mp.weixin.qq.com/s/4LdLgDmSH84WE_cxN6SmAw

## Redis
Redis采用的是基于内存的采用的是单进程单线程模型的KV数据库，由C语言编写。官方提供的数据是可以达到100000+的qps（每秒请求数）。这个数据不比采用单进程多线程的同样基于内存的KV数据库Memcached差。

1. 速度快，数据存储在内存中，查找和操作的时间复杂度都是0（1）
2. 支持丰富数据类型：字符串、列表、集合、散列、有序集合
3. 支持事务，操作都是原子性（要么全部执行，要么全不执行）
4. 丰富的特性：可用于缓存、消息队列、按key设置timeout 

Redis快的主要原因：  

1. 完全基于内存
2. 数据结构简单，对数据操作也简单
3. 使用多路 I/O 复用模型（“多路”指的是多个网络连接，“复用”指的是复用同一个线程，多个请求注册到一个多路复用器上）

Redis为什么被设计成单线程？  
在现在这个多核多CPU时代，为了充分利用CPU资源，加快应用运行速度，越来越多的应用被设计成多进程或者多线程。因为CPU不是Reids的瓶颈，网络资源才是瓶颈（官方FAQ）。故没必要设计成多线程，单线程的好处：编程更简单，不要考虑锁的问题，不存在加锁释放锁，不存在切换线程消耗CPU的资源。

## redis相比memcached有什么优势
1. memcached所有的值都是简单的字符串，redis作为其代替者，支持更丰富的数据类型
2. redis速度比memcached快很多
3. redis可以持久化其数据

## Redis的原子性
Redis所有单个命令的执行都是原子性的。  
Redis实现事物的原理：
	
	1. 批量操作在发送 EXEC 命令前被放入队列缓存
	2. 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令都不会被执行
	3. 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中

## mySQL里有2000w数据，redis中只能存20w的数据，如何保证redis中的数据都是热点数据

**Redis内存淘汰机制**：Redis内存淘汰指的是用户存储的一些键被可以被Redis主动地从实例中删除，从而产生读miss的情况，那么Redis为什么要有这种功能？为了更好地使用内存，用一定的缓存miss来换取内存的使用效率。  

	# maxmemory <bytes>

**内存淘汰策略**：其中默认的策略为noeviction策略  
	
	# maxmemory-policy noeviction

- noeviction：当内存使用达到阈值的时候，向造成占用空间超出配置值的命令返回错误结果。
- allkeys-lru：对所有键使用LRU算法删除键（包括设置了过期时间和没设置过期时间的键，即从reids所有键中选择）。
- volatile-lru：仅对设置了过期时间的键使用LRU算法删除【最近最少使用算法】（仅从设置了过期时间的键中选择
- allkeys-random：从所有键中随机选择键进行删除操作，直到占用内存小于maxmemory的配置值（包括设置了过期时间和没设置过期时间的键，即从reids所有键中选择）
- volatile-random：从设置了过期时间的键中随机选择键进行删除操作（仅从设置了过期时间的键中选择）
- volatile-ttl：删除离过期时间最近的键（即ttl值最小的值，因此只会在设置了过期时间的键中选择）

## 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？
使用keys指令可以扫出指定模式的key列表。（KEYS h*llo 匹配 hllo 和 heeeeello 等）   
对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？  
这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

SCAN 每次执行都只会返回少量元素，所以可以用于生产环境，而不会出现像 KEYS 或者 SMEMBERS 命令带来的可能会阻塞服务器的问题。SCAN命令是一个基于游标的迭代器。以 0 作为游标开始一次新的迭代， 一直调用 SCAN 命令， 直到命令返回游标 0 ， 我们称这个过程为一次完整遍历。

## Redis如何做持久化的？
**快照持久化**：Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。BGSAVE来创建一个快照，Redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。SAVE来创建一个快照，Redis服务器在快照创建完毕之前将不再响应任何其他命令。再使用快照持久化来保存数据时，一定要记住：如果系统真的发生崩溃，用户将丢失最近一次生成快照之后更改的所有数据。

**AOF持久化**：（append-only file）AOF持久化会将被执行的写命令写入到AOF文件的末尾，以此来记录数据发生的变化。appendfsync always表示每个Redis写命令都要同步写入硬盘。这样做会严重降低Redis的速度。 appendfsync everysec表示每秒执行一次同步，显式地将多个写命令同步到硬盘。BGREWRITEAOF用来重写／压缩AOF文件。

bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。

对方追问那如果突然机器掉电会怎样？取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。

对方追问BGSAVE的原理是什么？你给出两个词汇就可以了，fork和cow。fork是指Redis通过创建子进程来进行BGSAVE操作，cow指的是copy on write，写时复制：继续提供服务，只有当有人修改当前内存数据时，才去复制被修改的内存页，用于生成快照。所有Redis的RDB快照时精准的，精准到执行时刻的状态，因为使用了Copy-On-Write技术。

## Redis主从复制
redis的复制功能是支持多个数据库之间的数据同步。一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。

通过redis的复制功能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。

主从复制的过程：
  
1. 当一个从数据库启动时，会向主数据库发送sync命令。
2. 主数据库接收到sync命令后开始执行BGSAVE，并使用缓冲区记录BGSAVE之后执行的所有写命令。
3. 当快照完成后，主数据库会将快照文件和所有缓存的命令依次发送给从数据库。
4. 从数据库收到后，先清空原有的所有数据，再载入新发来的快照文件，以及执行新发来的缓冲区里的写命令。
5. 之后主数据库的写命令都会同步到从数据库。

配置Redis主从结构（一主多从）：   
通过redis-cli 连接到从节点服务器，执行下面命令即可。  

	slaveof 192.168.33.130 6379

注意点：如果你使用主从复制，那么要确保你的master激活了持久化，或者确保它不会在当掉后自动重启。  
原因：slave是master的完整备份，因此如果master通过一个空数据集重启，slave也会被清掉。   
如果master没有激活持久化，突然master宕机了，不可立即重启master，正确做法应该是：在slave下执行save生成快照，再拷到master路径下，启动master。

## Redis集群
Redis 集群是一个提供在多个Redis间节点间共享数据的程序集。 

Redis集群并不支持处理多个keys的命令,因为这需要在不同的节点间移动数据,从而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误.

redis cluster在设计的时候，就考虑到了去中心化，去中间件，也就是说，集群中的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。

Redis集群的优势：可以自动分割数据到不同的节点上。并且，整个集群的部分节点失败或者不可达的情况下，能够继续处理命令。Redis 集群没有使用一致性hash, 而是引入了 哈希槽的概念.Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:

	节点 A 包含 0 到 5500号哈希槽.  
	节点 B 包含5501 到 11000 号哈希槽.
	节点 C 包含11001 到 16384号哈希槽.
为什么哈希槽的数量固定为16384个？  http://blog.onlycatch.com/post/60c42de47e9a 
redis集群一致性问题 ： 异步复制 和 网络分割

## Redis的一些高级特性
SET 应用场景：我们事先建立好一系列的SET，实际上这些Set都是各种分类的ProductID集合。用户的搜索条件，实际上就是各种SET进行交、并、补的运算而已

#yangliyi314@163.com
